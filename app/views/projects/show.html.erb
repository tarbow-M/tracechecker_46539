<!-- データ表示・範囲選択ページ -->
<!-- 1. ヘッダー: プロジェクト名と親へのリンク -->
<div class="bg-white shadow-sm border-b border-gray-200">
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
    <div class="flex justify-between items-center">
      <div>
        <!-- 親プロジェクトへのパンくずリスト -->
        <%# @parent_project は ProjectsController#show で設定されます %>
        <%= link_to @parent_project.name, parent_project_path(@parent_project), class: "text-sm font-medium text-gray-500 hover:text-gray-700" %>
        
        <h1 class="text-2xl font-bold text-gray-900 mt-1">
          <%= @project.name %>
        </h1>
        
        <p class="text-sm text-gray-600 mt-1">
          ステータス: <span class="font-medium text-yellow-600"><%= @project.status || '未実行' %></span>
          <span class="mx-2 text-gray-300">|</span>
          最終実行: <%= @project.last_run ? @project.last_run.strftime('%Y/%m/%d %H:%M') : 'N/A' %>
        </p>
      </div>
      <div>
        <!-- TODO: 将来的に「編集」ボタンなどを設置 -->
        <%#= link_to "設定編集", edit_parent_project_project_path(@parent_project, @project), class: "py-2 px-4 rounded-lg bg-gray-200 hover:bg-gray-300 text-sm font-medium" %>
      </div>
    </div>
  </div>
</div>

<!-- 2. メインコンテンツ: 照合設定とプレビュー -->
<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
  <div class="bg-white p-6 rounded-xl shadow-lg border border-gray-200">

    <!-- 2-1. ファイル選択 -->
    <div class="mb-6 pb-6 border-b border-gray-200">
      <h2 class="text-xl font-semibold text-gray-800 mb-4">1. 照合対象ファイルの選択</h2>
      <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div>
          <label for="file_a_select" class="block text-sm font-medium text-gray-700 mb-1">資料A (比較元)</label>
          <!-- @files (親が持つファイル一覧) は ProjectsController#show で設定されます -->
          <select id="file_a_select" class="w-full border-gray-300 rounded-lg shadow-sm focus:border-blue-500 focus:ring-blue-500 p-3 border">
            <option value="">ファイルを選択してください</option>
            <% @files.each do |file| %>
              <%# TODO: ActiveStorage の URL を取得する方法 (rails_blob_path) が正しいか確認 %>
              <option value="<%= rails_blob_path(file) %>" data-filename="<%= file.filename.to_s %>"><%= file.filename.to_s %></option>
            <% end %>
          </select>
        </div>
        <div>
          <label for="file_b_select" class="block text-sm font-medium text-gray-700 mb-1">資料B (比較先)</label>
          <select id="file_b_select" class="w-full border-gray-300 rounded-lg shadow-sm focus:border-blue-500 focus:ring-blue-500 p-3 border">
            <option value="">ファイルを選択してください</option>
            <% @files.each do |file| %>
              <option value="<%= rails_blob_path(file) %>" data-filename="<%= file.filename.to_s %>"><%= file.filename.to_s %></option>
            <% end %>
          </select>
        </div>
      </div>
      <div class="mt-4 text-center">
        <!-- TODO: 本番では、ファイルが選択されたらExcel/CSVを読み込みプレビューする -->
        <button id="load-preview-btn" onclick="simulateFileSelection()" class="bg-blue-600 hover:bg-blue-700 text-white py-2 px-5 rounded-lg font-medium shadow-md transition duration-150 ease-in-out">
          プレビュー表示
        </button>
        <p class="text-xs text-gray-500 mt-2">（※ 現在はダミーデータを表示します）</p>
      </div>
    </div>

    <!-- 2-2. 照合パターン選択 & 範囲指定 -->
    <div class="mb-6 pb-6 border-b border-gray-200">
      <h2 class="text-xl font-semibold text-gray-800 mb-4">2. 照合パターン選択 & 範囲指定</h2>
      <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        
        <!-- テンプレート選択 (Fetchで動的に読み込む) -->
        <div>
          <label for="template-select" class="block text-sm font-medium text-gray-700 mb-1">テンプレートを選択</label>
          <select id="template-select" class="border-gray-300 rounded-lg shadow-sm focus:border-green-500 focus:ring-green-500 p-3 border">
            <!-- JavaScript (loadTemplates) によって動的に <option> が挿入されます -->
            <option value="">テンプレートを選択...</option>
          </select>
        </div>

        <div class="flex items-center space-x-3">
          <!-- TODO: 過去の照合結果（アーカイブ）を参照する機能 -->
          <button id="reset-selection-btn" onclick="resetSelectionMode()" class="bg-gray-200 hover:bg-gray-300 text-gray-800 py-2 px-4 rounded-lg font-medium">
            範囲指定リセット
          </button>
          <button id="toggle-selection-mode-btn" onclick="toggleSelectionMode()" class="bg-yellow-500 hover:bg-yellow-600 text-white py-2 px-4 rounded-lg font-medium shadow-md">
            範囲指定モード開始
          </button>
        </div>
      </div>
      <p id="selection-status-a" class="text-sm text-gray-600 mt-2">資料A: 0 セル選択中</p>
      <p id="selection-status-b" class="text-sm text-gray-600 mt-2">資料B: 0 セル選択中</p>
    </div>

    <!-- 2-3. 照合実行 -->
    <div class="text-center mb-6">
      <button id="start-comparison-btn" onclick="startComparison()" class="bg-green-600 hover:bg-green-700 text-white text-lg font-semibold py-3 px-8 rounded-lg shadow-lg transition duration-150 ease-in-out">
        照合実行
      </button>
    </div>

    <!-- 2-4. 照合結果サマリー (照合実行後に表示) -->
    <div id="result-summary" class="hidden bg-gray-50 p-6 rounded-lg border border-gray-200">
      <h3 class="text-lg font-semibold text-gray-800 mb-3">照合結果サマリー</h3>
      <div class="flex justify-between items-center">
        <div>
          <p id="diff-count" class="text-2xl font-bold text-red-600">差異: 0件</p>
          <p id="match-count" class="text-lg text-green-600">一致: 0件</p>
          <p id="unmatched-a-count" class="text-lg text-yellow-600">資料Aのみ: 0件</p>
          <p id="unmatched-b-count" class="text-lg text-yellow-600">資料Bのみ: 0件</p>
        </div>
        <div class="flex flex-col space-y-3">
          <button id="export-result-btn" class="bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-lg font-medium">
            結果エクスポート (CSV)
          </button>
          <!-- テンプレート保存機能 (Fetch POST) -->
          <button id="save-template-btn" onclick="openSaveTemplateModal()" class="bg-purple-500 hover:bg-purple-600 text-white py-2 px-4 rounded-lg font-medium">
            選択範囲をテンプレートに保存
          </button>
          <!-- TODO: アーカイブ（証跡）保存機能 -->
          <button id="archive-result-btn" class="bg-red-600 hover:bg-red-700 text-white py-2 px-4 rounded-lg font-medium">
            証跡としてアーカイブ保存
          </button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- 3. メインコンテンツ: 比較プレビュー -->
<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
  <div class="comparison-area grid grid-cols-1 md:grid-cols-2 gap-6">
    
    <!-- 資料A プレビュー -->
    <div id="doc-view-a" class="doc-view relative border border-gray-200 p-4 rounded-lg bg-white shadow-sm">
      <h3 class="text-lg font-semibold mb-4 text-gray-700">資料A プレビュー</h3>
      <div id="preview-area-a" class="overflow-auto max-h-[600px] relative">
        <!-- ダミーデータがここに挿入されます -->
        <table class="w-full border-collapse text-sm">
          <thead>
            <tr class="bg-gray-100">
              <th class="border p-2 text-left text-gray-600">キー</th>
              <th class="border p-2 text-left text-gray-600">目標</th>
              <th class="border p-2 text-left text-gray-600">結果</th>
            </tr>
          </thead>
          <tbody id="dummy-table-a">
            <!-- JavaScript (generatePreviewTable) によって挿入 -->
          </tbody>
        </table>
      </div>
    </div>
    
    <!-- 資料B プレビュー -->
    <div id="doc-view-b" class="doc-view relative border border-gray-200 p-4 rounded-lg bg-white shadow-sm">
      <h3 class="text-lg font-semibold mb-4 text-gray-700">資料B プレビュー</h3>
      <div id="preview-area-b" class="overflow-auto max-h-[600px] relative">
        <!-- ダミーデータがここに挿入されます -->
        <table class="w-full border-collapse text-sm">
          <thead>
            <tr class="bg-gray-100">
              <th class="border p-2 text-left text-gray-600">キー</th>
              <th class="border p-2 text-left text-gray-600">目標</th>
              <th class="border p-2 text-left text-gray-600">結果</th>
            </tr>
          </thead>
          <tbody id="dummy-table-b">
            <!-- JavaScript (generatePreviewTable) によって挿入 -->
          </tbody>
        </table>
      </div>
    </div>
    
  </div>
</div>


<!-- モーダル: テンプレート保存 -->
<div id="template-name-modal" class="modal fixed inset-0 flex items-center justify-center hidden bg-gray-900 bg-opacity-50 z-50">
  <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md transform transition-all">
    <h3 class="text-2xl font-bold text-gray-900 mb-4 border-b pb-2">テンプレート新規保存</h3>
    <p class="mb-4 text-sm text-gray-600">現在の選択範囲（AとB）を保存します。テンプレート名を入力してください。</p>
    <form id="template-name-form">
      <div class="mb-4">
        <label for="template-name" class="block text-sm font-medium text-gray-700 mb-1">テンプレート名</label>
        <input type="text" id="template-name" required class="w-full border-gray-300 rounded-lg shadow-sm focus:border-purple-500 focus:ring-purple-500 p-3 border" placeholder="例: 月次KPI報告">
      </div>
      <div class="flex justify-end space-x-3">
        <button type="button" onclick="closeModal('template-name-modal')" class="bg-gray-200 hover:bg-gray-300 text-gray-800 py-2 px-4 rounded-lg font-medium">キャンセル</button>
        <button type="submit" class="bg-purple-600 hover:bg-purple-700 text-white py-2 px-4 rounded-lg font-medium">保存</button>
      </div>
    </form>
  </div>
</div>


<!-- 
  ==============================================
  JavaScript
  ==============================================
  - ダミーデータの生成 (コントローラから渡される)
  - プレビューの生成 (ダミー)
  - 範囲選択ロジック (デモ版)
  - 照合実行ロジック (デモ版)
  - テンプレート機能 (Fetch API)
-->
<style>
  /* デモ版のハイライト用CSS */
  .diff-highlight { background-color: #fecaca !important; } /* 赤 (差異) */
  .match-highlight { background-color: #d1fae5 !important; } /* 緑 (一致) */
  .unmatched-highlight { background-color: #fff3cd !important; } /* 黄 (片方のみ) */
  
  /* テンプレート選択（青） */
  .template-highlight { 
    background-color: rgba(191, 219, 254, 0.5) !important; /* 青 (選択範囲/テンプレート) */
    cursor: pointer; /* 選択解除用のカーソル */
  } 

  /* 照合範囲（赤枠） */
  .comparison-cell-border {
    border: 2px dashed #ef4444 !important; /* 赤の点線 */
  }
  
  /* 範囲指定モード中のカーソル */
  .select-mode-active .doc-view { 
    border-color: #f59e0b; 
    border-style: dashed; 
    border-width: 3px; 
    cursor: crosshair; /* マウスオーバーでカーソルが変わる */
  }
</style>

<script>
  // --- グローバル変数 ---
  // 1. コントローラからのデータ (ダミー)
  // (generate_dummy_data メソッドから渡される)
  const dummyDataA = <%= raw @dummy_data_a.to_json %>;
  const dummyDataB = <%= raw @dummy_data_b.to_json %>;

  // 2. 状態管理
  let isSelectionMode = false;
  let isDragging = false;
  let startX, startY;
  let selectionBoxA = null;
  let selectionBoxB = null;
  let selectionCoordsA = { cells: [] }; 
  let selectionCoordsB = { cells: [] }; 
  let templatesCache = []; // 読み込んだテンプレートをキャッシュ

  // 3. 要素キャッシュ (DOMContentLoaded で設定)
  let docViewA, docViewB, previewAreaA, previewAreaB;
  let tableBodyA, tableBodyB, toggleBtn, templateSelect;

  // --- モーダル制御 (グローバル) ---
  function openModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) modal.classList.remove('hidden');
  }
  function closeModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) modal.classList.add('hidden');
  }

  // --- 1. プレビュー表示 (ダミー) ---
  // (※ 本番ではファイル選択時にExcel/CSVをパースする)
  function simulateFileSelection() {
    console.log("プレビュー表示 (ダミー)");
    generatePreviewTable(dummyDataA, tableBodyA, 'A');
    generatePreviewTable(dummyDataB, tableBodyB, 'B');
    // 範囲選択イベントリスナーをセットアップ
    setupSelectionListeners();
  }
  
  // ダミーデータからテーブルHTMLを生成
  function generatePreviewTable(data, tableBody, docId) {
    if (!tableBody) return; // 要素が見つからない場合は終了
    tableBody.innerHTML = ''; // クリア
    data.forEach((row, rowIndex) => {
      const tr = document.createElement('tr');
      // 3つの主要カラム (key, goal, result) を表示
      ['key', 'goal', 'result'].forEach((colKey, colIndex) => {
        const td = document.createElement('td');
        td.className = 'border p-2 comparable-cell';
        td.dataset.doc = docId;
        td.dataset.row = rowIndex; // 0-indexed row
        td.dataset.col = colIndex; // 0-indexed col
        // データ本体 (デモ版ではキーをそのままセル内容にする)
        td.dataset.key = row['key']; // 照合キー
        td.textContent = row[colKey];
        tr.appendChild(td);
      });
      tableBody.appendChild(tr);
    });
  }
  
  // --- 2. 範囲選択ロジック (デモ版) ---

  // 範囲指定モードのトグル
  function toggleSelectionMode() {
    isSelectionMode = !isSelectionMode;
    if (isSelectionMode) {
      docViewA.classList.add('select-mode-active');
      docViewB.classList.add('select-mode-active');
      toggleBtn.textContent = '範囲指定モード終了';
      toggleBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
      toggleBtn.classList.add('bg-red-500', 'hover:bg-red-600');
    } else {
      resetSelectionMode();
    }
  }

  // 範囲指定のリセット
  function resetSelectionMode() {
    isSelectionMode = false;
    if (docViewA) docViewA.classList.remove('select-mode-active');
    if (docViewB) docViewB.classList.remove('select-mode-active');
    if (toggleBtn) {
      toggleBtn.textContent = '範囲指定モード開始';
      toggleBtn.classList.remove('bg-red-500', 'hover:bg-red-600');
      toggleBtn.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
    }

    // 範囲指定をリセット
    selectionCoordsA.cells = [];
    selectionCoordsB.cells = [];
    
    // ハイライトをリセット
    // (※ 過去の照合結果ハイライト (赤/緑/黄) はリセットしない)
    document.querySelectorAll('.comparable-cell').forEach(cell => {
      cell.classList.remove('template-highlight'); // 青ハイライトのみ削除
      // 照合中の赤枠もリセットする
      cell.classList.remove('comparison-cell-border');
    });
    
    updateSelectionStatus();
  }
  
  // 選択イベントリスナーのセットアップ
  function setupSelectionListeners() {
    [previewAreaA, previewAreaB].forEach(area => {
      if (!area) return; // 要素が見つからない場合は終了
      
      // (mousedown, mousemove, mouseup はデモ版では省略)
      
      // クリックによるセル選択
      area.addEventListener('click', (e) => {
        if (!isSelectionMode) return;
        
        const cell = e.target.closest('.comparable-cell');
        if (!cell) return;

        const docId = cell.dataset.doc;
        // 座標を数値として保存
        const coords = { 
          row: parseInt(cell.dataset.row, 10), 
          col: parseInt(cell.dataset.col, 10) 
        };
        const selectionCache = (docId === 'A') ? selectionCoordsA : selectionCoordsB;

        // クリックで選択・選択解除
        const index = selectionCache.cells.findIndex(c => c.row === coords.row && c.col === coords.col);
        
        if (index > -1) {
          // 既に選択済み -> 選択解除
          selectionCache.cells.splice(index, 1);
          cell.classList.remove('template-highlight');
        } else {
          // 未選択 -> 選択
          selectionCache.cells.push(coords);
          cell.classList.add('template-highlight');
        }
        updateSelectionStatus();
      });
    });
  }

  // 選択ステータスの更新
  function updateSelectionStatus() {
    const statusA = document.getElementById('selection-status-a');
    const statusB = document.getElementById('selection-status-b');
    if (statusA) statusA.textContent = `資料A: ${selectionCoordsA.cells.length} セル選択中`;
    if (statusB) statusB.textContent = `資料B: ${selectionCoordsB.cells.length} セル選択中`;
  }

  // --- 3. 照合実行ロジック (デモ版) ---
  
  function startComparison() {
    console.log("照合実行 (デモ版ロジック)");
    
    // (1) 以前の照合結果ハイライト（赤/緑/黄）をリセット
    clearAllComparisonHighlights();

    // (2) 照合範囲（選択範囲 or テンプレート）のセルに赤枠（照合中）を適用
    if (selectionCoordsA.cells.length === 0 || selectionCoordsB.cells.length === 0) {
      alert("資料Aと資料B、両方の照合範囲を指定（またはテンプレートを適用）してください。");
      return;
    }
    
    // (3) 照合範囲のセルに赤枠を適用
    applyComparisonBorders(selectionCoordsA.cells, 'A');
    applyComparisonBorders(selectionCoordsB.cells, 'B');

    // (4) 照合範囲のデータセットを構築
    // (キー: dataset.key, 値: textContent)
    const datasetA = buildDataset(selectionCoordsA.cells, 'A');
    const datasetB = buildDataset(selectionCoordsB.cells, 'B');

    // (5) 照合ロジック (キーで比較)
    let diffCount = 0;
    let matchCount = 0;
    let unmatchedA = 0;
    let unmatchedB = 0;
    
    const matchedKeysB = new Set();

    datasetA.forEach(itemA => {
      const itemB = datasetB.find(b => b.key === itemA.key);
      
      if (itemB) {
        // キーが一致 (Bにも存在する)
        matchedKeysB.add(itemA.key);
        
        if (itemA.value === itemB.value) {
          // 値も一致
          matchCount++;
          applyHighlight(itemA.cellRef, 'match-highlight');
          applyHighlight(itemB.cellRef, 'match-highlight');
        } else {
          // 値が不一致 (差異)
          diffCount++;
          applyHighlight(itemA.cellRef, 'diff-highlight');
          applyHighlight(itemB.cellRef, 'diff-highlight');
        }
      } else {
        // キーがAにしか存在しない
        unmatchedA++;
        applyHighlight(itemA.cellRef, 'unmatched-highlight');
      }
    });

    // Bにしか存在しないキーをカウント
    datasetB.forEach(itemB => {
      if (!matchedKeysB.has(itemB.key)) {
        unmatchedB++;
        applyHighlight(itemB.cellRef, 'unmatched-highlight');
      }
    });

    // (6) 結果サマリーを表示
    document.getElementById('result-summary').classList.remove('hidden');
    document.getElementById('diff-count').textContent = `差異: ${diffCount}件`;
    document.getElementById('match-count').textContent = `一致: ${matchCount}件`;
    document.getElementById('unmatched-a-count').textContent = `資料Aのみ: ${unmatchedA}件`;
    document.getElementById('unmatched-b-count').textContent = `資料Bのみ: ${unmatchedB}件`;
  }
  
  // ハイライト適用 (共通)
  function applyHighlight(cellRef, highlightClass) {
    if (cellRef) {
      cellRef.classList.add(highlightClass);
    }
  }
  
  // 照合範囲の赤枠を適用
  function applyComparisonBorders(cells, docId) {
    cells.forEach(coord => {
      // 座標は数値で保存されている
      const cell = document.querySelector(`.comparable-cell[data-doc="${docId}"][data-row="${coord.row}"][data-col="${coord.col}"]`);
      if (cell) {
        cell.classList.add('comparison-cell-border');
      }
    });
  }

  // 照合データセットを構築 (キーと値)
  function buildDataset(cells, docId) {
    const dataset = [];
    cells.forEach(coord => {
      // 座標は数値で保存されている
      const cell = document.querySelector(`.comparable-cell[data-doc="${docId}"][data-row="${coord.row}"][data-col="${coord.col}"]`);
      if (cell) {
        dataset.push({
          key: cell.dataset.key, // 行のキー (dataset.key)
          value: cell.textContent, // セルの値
          cellRef: cell // セルDOMへの参照
        });
      }
    });
    return dataset;
  }
  
  // 照合結果ハイライト（赤/緑/黄）のみをクリア
  function clearAllComparisonHighlights() {
    const highlights = ['match-highlight', 'diff-highlight', 'unmatched-highlight'];
    document.querySelectorAll('.comparable-cell').forEach(cell => {
      cell.classList.remove(...highlights);
      // 照合赤枠もクリア
      cell.classList.remove('comparison-cell-border');
    });
  }


  // --- 4. テンプレート機能 (Fetch API) ---
  
  // (A) 画面ロード時: テンプレート一覧をサーバーから取得
  // (※ Turbo (Rails 7) は DOMContentLoaded を使わないため、 "turbo:load" を使う)
  document.addEventListener('turbo:load', () => {
    
    // --- 要素キャッシュ ---
    // (turbo:load のたびに要素を再取得する)
    docViewA = document.getElementById('doc-view-a');
    docViewB = document.getElementById('doc-view-b');
    previewAreaA = document.getElementById('preview-area-a');
    previewAreaB = document.getElementById('preview-area-b');
    tableBodyA = document.getElementById('dummy-table-a');
    tableBodyB = document.getElementById('dummy-table-b');
    toggleBtn = document.getElementById('toggle-selection-mode-btn');
    templateSelect = document.getElementById('template-select');

    // プレビュー表示ボタンが押されるまでダミーデータは表示しない
    // (※ simulateFileSelection() はボタン押下時にのみ呼ばれる)
    
    // テンプレートをロード
    loadTemplates();
    
    // (B) プルダウン変更時: テンプレート適用
    // (※ turbo:load のたびにリスナーを再設定しないよう、nullチェック)
    if (templateSelect && !templateSelect.dataset.listenerAttached) {
      templateSelect.addEventListener('change', (e) => {
        const selectedTemplateId = e.target.value;
        if (selectedTemplateId) {
          applyTemplate(selectedTemplateId);
        } else {
          // 「選択してください」に戻した場合 (青ハイライトのみリセット)
          resetTemplateHighlights();
        }
      });
      templateSelect.dataset.listenerAttached = 'true';
    }
    
    // (C) 保存フォーム送信時: テンプレート保存
    const templateForm = document.getElementById('template-name-form');
    if (templateForm && !templateForm.dataset.listenerAttached) {
      templateForm.addEventListener('submit', (e) => {
        e.preventDefault();
        const templateName = document.getElementById('template-name').value;
        // 現在の選択範囲 (JS変数) を取得
        const range = {
          a: selectionCoordsA.cells,
          b: selectionCoordsB.cells
        };
        
        if (!templateName) {
          alert("テンプレート名を入力してください。");
          return;
        }
        if (range.a.length === 0 || range.b.length === 0) {
          alert("資料Aと資料Bの範囲を指定（またはテンプレートを適用）してから保存してください。");
          return;
        }
        
        saveTemplate(templateName, range);
      });
      templateForm.dataset.listenerAttached = 'true';
    }
    
    // (D) プレビュー表示ボタン
    const previewBtn = document.getElementById('load-preview-btn');
    if (previewBtn && !previewBtn.dataset.listenerAttached) {
      previewBtn.onclick = simulateFileSelection; // (onclick属性の代わりにリスナーを設定)
      previewBtn.dataset.listenerAttached = 'true';
    }
    
    // (E) 範囲指定モードボタン
    if (toggleBtn && !toggleBtn.dataset.listenerAttached) {
      toggleBtn.onclick = toggleSelectionMode;
      toggleBtn.dataset.listenerAttached = 'true';
    }
    
    // (F) 範囲リセットボタン
    const resetBtn = document.getElementById('reset-selection-btn');
    if (resetBtn && !resetBtn.dataset.listenerAttached) {
      resetBtn.onclick = resetSelectionMode;
      resetBtn.dataset.listenerAttached = 'true';
    }
    
    // (G) 照合実行ボタン
    const compareBtn = document.getElementById('start-comparison-btn');
    if (compareBtn && !compareBtn.dataset.listenerAttached) {
      compareBtn.onclick = startComparison;
      compareBtn.dataset.listenerAttached = 'true';
    }
    
    // (H) テンプレート保存モーダルを開くボタン
    const saveTemplateBtn = document.getElementById('save-template-btn');
    if (saveTemplateBtn && !saveTemplateBtn.dataset.listenerAttached) {
      saveTemplateBtn.onclick = openSaveTemplateModal;
      saveTemplateBtn.dataset.listenerAttached = 'true';
    }
    
    // (I) モーダルを閉じるボタン
    const closeModalBtn = document.querySelector('#template-name-modal button[type="button"]');
    if (closeModalBtn && !closeModalBtn.dataset.listenerAttached) {
      closeModalBtn.onclick = () => closeModal('template-name-modal');
      closeModalBtn.dataset.listenerAttached = 'true';
    }
    
    // (J) その他 (エクスポート, アーカイブ)
    // ...
  });

  // GET /templates
  function loadTemplates() {
    const selectEl = document.getElementById('template-select');
    if (!selectEl) return; // 要素がなければ何もしない

    // fetch でサーバー (TemplatesController#index) にリクエスト
    fetch('/templates')
      .then(response => {
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        return response.json();
      })
      .then(templates => {
        // 取得成功
        templatesCache = templates; // キャッシュに保存
        
        // プルダウンをクリア (「選択...」を除く)
        while (selectEl.options.length > 1) {
          selectEl.remove(1);
        }
        
        // プルダウンにテンプレートを追加
        templates.forEach(template => {
          const option = document.createElement('option');
          option.value = template.id; // id (数値)
          option.textContent = template.name;
          selectEl.appendChild(option);
        });
      })
      .catch(error => {
        console.error('Error loading templates:', error);
        // alert('テンプレートの読み込みに失敗しました。');
      });
  }
  
  // テンプレートをプレビューに適用 (ハイライト)
  function applyTemplate(templateId) {
    const template = templatesCache.find(t => t.id == templateId);
    if (!template || !template.range) {
      alert("テンプレート情報の読み込みに失敗しました。");
      return;
    }

    // (1) 既存の青ハイライト（.template-highlight）と選択範囲（JS変数）をリセット
    resetTemplateHighlights();

    // (2) テンプレートの範囲 (range.a, range.b) を JS変数 (selectionCoords) にコピー
    // (※ range.a や range.b が null/undefined の場合も考慮)
    selectionCoordsA.cells = template.range.a || [];
    selectionCoordsB.cells = template.range.b || [];

    // (3) テンプレートの範囲を青くハイライト
    applyTemplateHighlights(selectionCoordsA.cells, 'A');
    applyTemplateHighlights(selectionCoordsB.cells, 'B');
    
    // (4) 選択ステータスを更新
    updateSelectionStatus();
  }
  
  // テンプレート（青）ハイライトとJS変数のみをリセットする
  function resetTemplateHighlights() {
    selectionCoordsA.cells = [];
    selectionCoordsB.cells = [];
    document.querySelectorAll('.comparable-cell').forEach(cell => {
      cell.classList.remove('template-highlight');
    });
    updateSelectionStatus();
  }
  
  // テンプレートのハイライト（青）を適用
  function applyTemplateHighlights(cells, docId) {
    if (!cells) return;
    cells.forEach(coord => {
      // 座標は {row: X, col: Y} の形式で保存されている
      const cell = document.querySelector(`.comparable-cell[data-doc="${docId}"][data-row="${coord.row}"][data-col="${coord.col}"]`);
      if (cell) {
        cell.classList.add('template-highlight');
      }
    });
  }

  // 保存ボタン（モーダルを開く）
  function openSaveTemplateModal() {
    if (selectionCoordsA.cells.length === 0 || selectionCoordsB.cells.length === 0) {
      alert("資料Aと資料Bの範囲を指定（またはテンプレートを適用）してから保存してください。");
      return;
    }
    const templateNameInput = document.getElementById('template-name');
    if (templateNameInput) templateNameInput.value = ''; // 入力欄をクリア
    openModal('template-name-modal');
  }

  // POST /templates
  function saveTemplate(templateName, range) {
    // Rails の CSRF トークンを取得
    const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
    if (!csrfToken) {
        console.error('CSRF token not found');
        alert('セキュリティトークンが見つかりません。ページをリロードしてください。');
        return;
    }

    // fetch でサーバー (TemplatesController#create) にリクエスト
    fetch('/templates', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': csrfToken, // CSRF トークンをヘッダーに含める
        'Accept': 'application/json'
      },
      // JavaScript オブジェクトを JSON 文字列に変換して送信
      body: JSON.stringify({
        template: {
          name: templateName,
          range: range // { a: [{row:X, col:Y}, ...], b: [...] }
        }
      })
    })
    .then(response => {
      if (!response.ok) {
        // バリデーションエラー (422) などもここで処理
        return response.json().then(err => Promise.reject(err));
      }
      return response.json(); // RailsからのレスポンスをJSONとしてパース
    })
    .then(newTemplate => {
      // (B) 保存成功
      alert(`テンプレート「${newTemplate.name}」を保存しました。`);
      closeModal('template-name-modal');
      
      // (C) プルダウンを再読み込み (新しいテンプレートを含めるため)
      loadTemplates(); 
      
      // (D) (オプション) 保存したテンプレートを即座に選択状態にする
      // (※ loadTemplates が非同期なので、少し工夫が必要)
      // (※ 今回は再読み込みのみ)
    })
    .catch(error => {
      console.error('Error saving template:', error);
      if (error.errors) {
        // (A) 保存失敗 (バリデーションエラーなど)
        alert('テンプレートの保存に失敗しました:\n' + error.errors.join('\n'));
      } else {
        alert('テンプレートの保存中にエラーが発生しました。');
      }
    });
  }

</script>


